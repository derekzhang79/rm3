#!/usr/bin/env node

var query = require('../lib/query');
var entity = require('../lib/entity');
var sitepath = require ('sitepath');
var db = require('../lib/db');
var program = require('commander');
var pjson = require('../package.json');
var async = require('async');
var util = require('util');
var fs = require('fs');
var winston = require('winston');
var path = require('path');
var dumpEntity = require('../lib/dumpentity.js');

winston.cli();

function parse_sitepath(val) {
  var pth = new sitepath(val);
  return pth;
}

var dirVal;

function writeNodeToFile(outPath, ent, log, next)
{
  var rec = ent.toRec();
  rec.history = log;
  rec.dump_date = new Date();
  rec.dump_version = pjson.version;
  fs.open(outPath, 'wx', 0666, function(err, fd) {
    if (err) {
      return next(err);
    }
    fs.writeSync(fd, JSON.stringify(rec));
    fs.closeSync(fd);
  })
  next();
}

function writeEntityBackup(backupPath, concurrency, dir, next) {
  var catalog = {};
  winston.info('Starting backup, concurrency :', program.concurrency);
  query.sequentialEntityScan(db, {}, backupPath, program.concurrency, function(entry, next) {
    winston.info('Backing up :', entry.path);
    var pth = new sitepath(entry.path);
    dumpEntity(db, entity.Entity, pth, true, function(err, ent, log) {
      if (err) {
        return next(err);
      }
      var filepath = path.join(dir, entry.path + '-data.json');
      writeNodeToFile(filepath, ent, log, next);
      catalog[entry.path] = {main: entry.path + '-data.json'};
    })
  }, function(err) {
    next(err, catalog);
  });
};

function writePermissionBackup(dir, catalog, next) {
  winston.info('Writing RBAC permissions and roles');
  var rolesQuery = query.listRoles(db, {});
  var roles = [];
  var records = [];
  rolesQuery.on('article', function(role) {
    roles.push(role);
  });
  rolesQuery.on('end', function() {
    async.eachSeries(roles, function(role, cb) {
      var permissions = query.listPermissionsInRole(db, {}, role.role);
      permissions.on('article', function(permission) {
        records.push({
          type: "permit", 
          role: role.role,
          permission: permission.permission,
          path: permission.path})
      });
      permissions.on('end', function() {
        cb();
      });
    }, function(err) {
      catalog._permissions = 'permissions.json';
      var outPath = path.join(dir, 'permissions.json');
      fs.open(outPath, 'wx', 0666, function(err, fd) {
        if (err) {
          return next(err);
        }
        fs.writeSync(fd, JSON.stringify(records));
        fs.closeSync(fd);
        winston.info('RBAC permissions and roles written');
        next(err, catalog);
      });
    });
  });
}

program
  .arguments('<dir>')
  .version(pjson.version)  
  .option('-c, --concurrency <concurrency>','Number of processes of concurrency', 1)
  .option('-p, --path [path]','Get path',parse_sitepath,new sitepath(['wh']))
  .action(function (dirParam) {
    dirVal = dirParam;
    var dir = path.join(process.cwd(), dirParam)
    try {
      winston.info('Creating directory :', dir)
      fs.mkdirSync(dir);
    } catch(e) {
      if (e.code === 'EEXIST') {
        winston.error('Can\'t create dir, already exists.');
        winston.info('rm3backup needs to be able to create an empty dir to give you a consistent backup.');
        process.exit(1);
      }
      winston.error('Can\'t create dir, error :', e);
      process.exit(1);
    }
    async.waterfall(
      [writeEntityBackup.bind(this, program.path, program.concurrency, dir),
      writePermissionBackup.bind(this, dir),
      function(catalog, next) {
        catalog._dump_date = new Date();
        catalog._dump_version = pjson.version;
        var outPath = path.join(dir, 'catalog.json');
        fs.open(outPath, 'wx', 0666, function(err, fd) {
          if (err) {
            return next(err);
          }
          fs.writeSync(fd, JSON.stringify(catalog));
          fs.closeSync(fd);
          next();
        });
      }
      ], 
      function(err) {
        if (err) {
          winston.error('Error while backing up:', err);
        }
        winston.info('Backup complete')
        db.gunDatabase();
      }
    );
  });
  ;

program.parse(process.argv);

if (typeof dirVal === 'undefined') {
 winston.error('No directory given');
 process.exit(1);
}